#include "GameManager.h"
#include "resource.h"
#include "Share/Timer.h"

DEFINITION_SINGLE(CGameManager)

bool CGameManager::mLoop = true;

CGameManager::CGameManager()
{
}

CGameManager::~CGameManager()
{
    ReleaseDC(mhWnd, mhDC);
}

bool CGameManager::Init(HINSTANCE hInst)
{
	mhInst = hInst;

	lstrcpy(mClassName, TEXT("KDT2Framework"));
	lstrcpy(mTitleName, TEXT("KDT2Framework"));

    RegisterWindowClass();

    if (!Create())
        return false;

    // 인자로 들어간 윈도우에 출력할 수 있는 DC가 만들어진다.
    mhDC = GetDC(mhWnd);

    // 타이머 초기화
    CTimer::Init();

	return true;
}

int CGameManager::Run()
{
    MSG msg;

    while (mLoop)
    {
        if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
        {
            // 키보드 입력 메세지가 발생할 경우 동작한다.
            // WM_KEYDOWN, WM_KEYUP 등 메세지가 발생하면 문자일 경우 WM_CHAR 메세지를 하나더
            // 만들어주는 역할을 한다.
            TranslateMessage(&msg);

            // 메세지를 WndProc로 전달해준다.
            DispatchMessage(&msg);
        }

        // 윈도우 데드타임일 경우 동작한다.(메세지 큐에 메세지가 없는 경우)
        else
        {
            Logic();
        }
    }

	return (int)msg.wParam;
}

void CGameManager::Logic()
{
    float DeltaTime = CTimer::Update();

    Input(DeltaTime);

    Update(DeltaTime);

    PostUpdate(DeltaTime);

    Collision(DeltaTime);

    PostCollisionUpdate(DeltaTime);

    Render(DeltaTime);
}

void CGameManager::Input(float DeltaTime)
{
    FVector2D   PlayerMoveDir;

    if (GetAsyncKeyState('W') & 0x8000)
    {
        PlayerMoveDir.y -= 1.f;
        /*mRC.Top -= 400 * DeltaTime;
        mRC.Bottom -= 400 * DeltaTime;*/
    }

    if (GetAsyncKeyState('S') & 0x8000)
    {
        PlayerMoveDir.y += 1.f;
        /*mRC.Top += 400 * DeltaTime;
        mRC.Bottom += 400 * DeltaTime;*/
    }

    if (GetAsyncKeyState('A') & 0x8000)
    {
        PlayerMoveDir.x -= 1.f;
        /*mRC.Left -= 400 * DeltaTime;
        mRC.Right -= 400 * DeltaTime;*/
    }

    if (GetAsyncKeyState('D') & 0x8000)
    {
        PlayerMoveDir.x += 1.f;
        /*mRC.Left += 400 * DeltaTime;
        mRC.Right += 400 * DeltaTime;*/
    }

    PlayerMoveDir.Normalize();

    mPlayerPos += PlayerMoveDir * 400.f * DeltaTime;

    if (GetAsyncKeyState(VK_SPACE) & 0x8000)
    {
        FBullet   Bullet;

        Bullet.Pos.x = mPlayerPos.x + mPlayerSize.x / 2.f + 25.f;
        Bullet.Pos.y = mPlayerPos.y;

        Bullet.Size = FVector2D(50.f, 50.f);
        Bullet.MoveDir = FVector2D(1.f, 0.f);

        Bullet.Distance = 1000.f;

        mBulletList.push_back(Bullet);
    }


    if (GetAsyncKeyState('1') & 0x8000)
    {
        for (int i = 0; i < 3; ++i)
        {
            FBullet   Bullet;

            Bullet.Pos.x = mPlayerPos.x + mPlayerSize.x / 2.f + 25.f;
            Bullet.Pos.y = mPlayerPos.y;

            Bullet.Size = FVector2D(50.f, 50.f);
            Bullet.MoveDir = FVector2D(1.f, i - 1.f);
            Bullet.MoveDir.Normalize();

            Bullet.Distance = 1000.f;

            mBulletList.push_back(Bullet);
        }
    }

    if (GetAsyncKeyState('2') & 0x8000)
    {
        FVector2D   Dir[8] =
        {
            {1.f, 0.f},
            {1.f, 1.f},
            {0.f, 1.f},
            {-1.f, 1.f},
            {-1.f, 0.f},
            {-1.f, -1.f},
            {0.f, -1.f},
            {1.f, -1.f}
        };

        for (int i = 0; i < 8; ++i)
        {
            FBullet   Bullet;

            Bullet.Size = FVector2D(50.f, 50.f);
            Bullet.MoveDir = Dir[i];
            Bullet.MoveDir.Normalize();

            Bullet.Pos = mPlayerPos + Bullet.MoveDir * 100.f;

            Bullet.Distance = 1000.f;

            mBulletList.push_back(Bullet);
        }
    }
}

void CGameManager::Update(float DeltaTime)
{
    std::list<FBullet>::iterator  iter = mBulletList.begin();
    std::list<FBullet>::iterator  iterEnd = mBulletList.end();

    for (; iter != iterEnd;)
    {
        FVector2D   Move = (*iter).MoveDir * 500.f * DeltaTime;

        (*iter).Pos += Move;

        float   Dist = Move.Length();

        (*iter).Distance -= Dist;

        if ((*iter).Distance <= 0.f)
        {
            iter = mBulletList.erase(iter);
            iterEnd = mBulletList.end();
            continue;
        }

        else if ((*iter).Pos.x + (*iter).Size.x / 2.f <= 0.f ||
            (*iter).Pos.y + (*iter).Size.y / 2.f <= 0.f ||
            (*iter).Pos.y - (*iter).Size.y / 2.f >= 720.f ||
            (*iter).Pos.x - (*iter).Size.x / 2.f >= 1280.f)
        {
            // 화면을 넘어간 총알을 제거한다. erase를 통해 list에서 제거하고
            // 제거한 다음노드를 가지고 있는 iterator를 반환해준다.
            iter = mBulletList.erase(iter);
            iterEnd = mBulletList.end();
            continue;
        }

        ++iter;
    }

    // 적을 이동시킨다.
    mEnemyPos.y += mEnemyDir * 300.f * DeltaTime;
    /*mEnemyRC.Top += mEnemyDir * 300.f * DeltaTime;
    mEnemyRC.Bottom += mEnemyDir * 300.f * DeltaTime;*/

    // 아래쪽이 바닥을 넘어갔을 경우
    if (mEnemyPos.y + mEnemySize.y / 2.f >= 720.f)
    {
        mEnemyPos.y = 670.f;
        /*mEnemyRC.Bottom = 720.f;
        mEnemyRC.Top = 620.f;*/
        mEnemyDir = -1.f;
    }

    // 위쪽이 화면의 상단을 넘어갔을 경우
    else if (mEnemyPos.y - mEnemySize.y / 2.f <= 0.f)
    {
        mEnemyPos.y = 50.f;
        /*mEnemyRC.Bottom = 100.f;
        mEnemyRC.Top = 0.f;*/
        mEnemyDir = 1.f;
    }


    std::list<FBullet>::iterator iter1 = mEnemyBulletList.begin();
    std::list<FBullet>::iterator iter1End = mEnemyBulletList.end();

    for (; iter1 != iter1End;)
    {
        FVector2D   Move = (*iter1).MoveDir * 500.f * DeltaTime;

        (*iter1).Pos += Move;

        float   Dist = Move.Length();

        (*iter1).Distance -= Dist;

        if ((*iter1).Distance <= 0.f)
        {
            iter1 = mEnemyBulletList.erase(iter1);
            iter1End = mEnemyBulletList.end();
            continue;
        }

        else if ((*iter1).Pos.x + (*iter1).Size.x / 2.f <= 0.f ||
            (*iter1).Pos.y + (*iter1).Size.y / 2.f <= 0.f ||
            (*iter1).Pos.y - (*iter1).Size.y / 2.f >= 720.f ||
            (*iter1).Pos.x - (*iter1).Size.x / 2.f >= 1280.f)
        {
            // 화면을 넘어간 총알을 제거한다. erase를 통해 list에서 제거하고
            // 제거한 다음노드를 가지고 있는 iterator를 반환해준다.
            iter1 = mEnemyBulletList.erase(iter1);
            iter1End = mEnemyBulletList.end();
            continue;
        }

        ++iter1;
    }


    mFireAccTime += DeltaTime;

    if (mFireAccTime >= mFireTime)
    {
        //mFireAccTime = 0.f;
        mFireAccTime -= mFireTime;

        // 총알의 시작위치는 적의 왼쪽에 만들어준다.
        FBullet Bullet;

        Bullet.Pos.x = mEnemyPos.x - mEnemySize.x / 2.f - 25.f;
        Bullet.Pos.y = mEnemyPos.y;

        Bullet.Size = FVector2D(50.f, 50.f);
        Bullet.MoveDir = mPlayerPos - Bullet.Pos;
        Bullet.MoveDir.Normalize();

        Bullet.Distance = 600.f;

        mEnemyBulletList.push_back(Bullet);
    }
}

void CGameManager::PostUpdate(float DeltaTime)
{
}

void CGameManager::Collision(float DeltaTime)
{
}

void CGameManager::PostCollisionUpdate(float DeltaTime)
{
}

void CGameManager::Render(float DeltaTime)
{
    //Rectangle(mhDC, 1, 1, 1279, 719);

    //Rectangle(mhDC, (int)mRC.Left, (int)mRC.Top, (int)mRC.Right, (int)mRC.Bottom);
    Rectangle(mhDC, (int)(mPlayerPos.x - mPlayerSize.x / 2.f),
        (int)(mPlayerPos.y - mPlayerSize.y / 2.f),
        (int)(mPlayerPos.x + mPlayerSize.x / 2.f),
        (int)(mPlayerPos.y + mPlayerSize.y / 2.f));

    std::list<FBullet>::iterator  iter = mBulletList.begin();
    std::list<FBullet>::iterator  iterEnd = mBulletList.end();

    for (; iter != iterEnd; ++iter)
    {
        Ellipse(mhDC, (int)((*iter).Pos.x - (*iter).Size.x / 2.f),
            (int)((*iter).Pos.y - (*iter).Size.y / 2.f),
            (int)((*iter).Pos.x + (*iter).Size.x / 2.f),
            (int)((*iter).Pos.y + (*iter).Size.y / 2.f));
    }

    /*Rectangle(mhDC, (int)mEnemyRC.Left, (int)mEnemyRC.Top, 
        (int)mEnemyRC.Right, (int)mEnemyRC.Bottom);*/
    Rectangle(mhDC, (int)(mEnemyPos.x - mEnemySize.x / 2.f),
        (int)(mEnemyPos.y - mEnemySize.y / 2.f),
        (int)(mEnemyPos.x + mEnemySize.x / 2.f),
        (int)(mEnemyPos.y + mEnemySize.y / 2.f));

    std::list<FBullet>::iterator iter1 = mEnemyBulletList.begin();
    std::list<FBullet>::iterator iter1End = mEnemyBulletList.end();

    for (; iter1 != iter1End; ++iter1)
    {
        Ellipse(mhDC, (int)((*iter1).Pos.x - (*iter1).Size.x / 2.f),
            (int)((*iter1).Pos.y - (*iter1).Size.y / 2.f),
            (int)((*iter1).Pos.x + (*iter1).Size.x / 2.f),
            (int)((*iter1).Pos.y + (*iter1).Size.y / 2.f));
    }
}

void CGameManager::RegisterWindowClass()
{
    WNDCLASSEXW wcex;

    // 윈도우클래스 구조체의 크기를 나타낸다. 반드시 지정되어야 한다.
    wcex.cbSize = sizeof(WNDCLASSEX);

    // 화면에 출력가능한 영역을 클라이언트 영역이라고 한다.
    // 클라이언트 영역의 크기(가로, 세로)가 변경될 시 전부 다시 그려주도록 한다.
    wcex.style = CS_HREDRAW | CS_VREDRAW;

    // 메세지큐에서 얻어온 메세지를 인자로 넣어서 호출해줄 함수의 주소를 넘겨준다.
    wcex.lpfnWndProc = WndProc;
    wcex.cbClsExtra = 0;
    wcex.cbWndExtra = 0;

    // 운영체제에서 부여해준 HINSTANCE를 전달한다.
    wcex.hInstance = mhInst;

    // 실행파일 아이콘을 지정한다.
    wcex.hIcon = LoadIcon(mhInst, MAKEINTRESOURCE(IDI_ICON1));

    // 윈도우 창에서의 커서 모양을 나타낸다.
    wcex.hCursor = LoadCursor(nullptr, IDC_ARROW);

    // 클라이언트 영역의 색상을 지정한다.
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);

    // 윈도우 메뉴를 지정한다.
    // 0을 대입하면 메뉴를 없앤다.
    wcex.lpszMenuName = 0;

    // 등록할 윈도우클래스의 이름을 지정한다.
    wcex.lpszClassName = mClassName;

    // 윈도우창 좌측 상단의 작은 아이콘을 지정한다.
    wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_ICON1));

    // 위에서 설정한 윈도우클래스를 등록한다.
    RegisterClassExW(&wcex);
}

bool CGameManager::Create()
{
    // CreateWindow : 윈도우 창을 생성해주는 함수이다.
    // WinAPI에서 함수명뒤에 W가 붙으면 유니코드, A가 붙으면 멀티바이트이다.
    // 1번인자 : 윈도우 클래스 이름을 지정한다.
    // 2번인자 : 윈도우 타이틀바에 출력할 이름을 지정한다.
    // 3번인자 : 윈도우 창의 모양을 결정한다.
    // 4번인자 : 화면에서 윈도우가 시작할 X지점을 지정한다.
    // 5번인자 : 화면에서 윈도우가 시작할 Y지점을 지정한다.
    // 6번인자 : 윈도우 창의 가로 크기를 지정한다.
    // 7번인자 : 윈도우 창의 세로 크기를 지정한다.
    // 8번인자 : 부모윈도우가 있을 경우 부모윈도우의 핸들을 지정한다.
    // 9번인자 : 메뉴 핸들을 전달한다.
    // 10번인자 : 윈도우 인스턴스를 전달한다. WinMain에서 전달은 값으로 전달해야 한다.
    // 11번인자 : 창 생성 데이터를 지정한다. WM_CREATE는 윈도우 생성시 발생하는 메세지인데
    // 이 메세지가 발생하면 WndProc 함수의 lParam에 이 값이 전달된다.
    // 이렇게 윈도우를 생성하면 윈도우 핸들을 만들어준다.
    // 잘못된 생성일 경우 0을 반환한다.
    mhWnd = CreateWindowW(mClassName, mTitleName, WS_OVERLAPPEDWINDOW,
        -1700, 100, 1280, 720, nullptr, nullptr, mhInst, nullptr);

    if (!mhWnd)
    {
        return false;
    }

    // 윈도우 클라이언트 영역의 크기를 원하는 크기로 지정한다.
    // 위에서 지정한 윈도우 크기는 타이틀바 등의 크기가 모두 합쳐진 크기로 지정된다.
    RECT    WindowRC = { 0, 0, 1280, 720 };

    // 클라이언트 영역이 1280, 720이 되기 위해 필요한 윈도우 전체 크기를 얻어온다.
    // (ThickFrame, Menu, TitleBar 등이 포함된 전체크기)
    AdjustWindowRect(&WindowRC, WS_OVERLAPPEDWINDOW, FALSE);

    SetWindowPos(mhWnd, HWND_TOPMOST, -1700, 100, WindowRC.right - WindowRC.left,
        WindowRC.bottom - WindowRC.top, SWP_NOMOVE | SWP_NOZORDER);

    // 위에서 윈도우 창을 만들었다면 ShowWindow 함수를 이용해서 창을 보여줄지 숨길지를
    // 결정한다.
    ShowWindow(mhWnd, SW_SHOW);

    // 클라이언트 영역을 강제로 다시 그리게 요청해주는 함수이다.
    // 처음 생성시나 특정상황에 창을 새로고침 해야 할 경우 사용한다.
    UpdateWindow(mhWnd);

    return true;
}

LRESULT CGameManager::WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    // 윈도우 창 종료메세지
    case WM_DESTROY:
        mLoop = false;
        PostQuitMessage(0);
        break;
    default:
        // 위에서 지정한 메세지 외의 다른 메세지가 발생할 경우 윈도우의 기본 동작으로
        // 처리가 되게 만들어준다.
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}
