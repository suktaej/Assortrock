#include "SceneComponent.h"

CSceneComponent::CSceneComponent()
{
}

CSceneComponent::CSceneComponent(const CSceneComponent& Com) :
    CComponent(Com)
{
}

CSceneComponent::CSceneComponent(CSceneComponent&& Com) :
    CComponent(Com)
{
}

CSceneComponent::~CSceneComponent()
{
}

void CSceneComponent::AddChild(CSceneComponent* Child)
{
    Child->mParent = this;

    mChildList.emplace_back(Child);
}

bool CSceneComponent::Init()
{
    return true;
}

bool CSceneComponent::Init(const char* FileName)
{
    return true;
}

void CSceneComponent::PreUpdate(float DeltaTime)
{
    CComponent::PreUpdate(DeltaTime);
}

void CSceneComponent::Update(float DeltaTime)
{
    CComponent::Update(DeltaTime);
}

void CSceneComponent::PostUpdate(float DeltaTime)
{
    CComponent::PostUpdate(DeltaTime);
}

void CSceneComponent::Collision(float DeltaTime)
{
    CComponent::Collision(DeltaTime);
}

void CSceneComponent::PreRender()
{
    CComponent::PreRender();
}

void CSceneComponent::Render()
{
    CComponent::Render();
}

void CSceneComponent::PostRender()
{
    CComponent::PostRender();
}

CSceneComponent* CSceneComponent::Clone()
{
    return new CSceneComponent(*this);
}

void CSceneComponent::SetRelativeScale(const FVector3D& Scale)
{
    mRelativeScale = Scale;

    if (mParent)
    {
        mWorldScale = mRelativeScale * mParent->mWorldScale;
    }

    else
    {
        mWorldScale = mRelativeScale;
    }

    size_t  Size = mChildList.size();

    for (size_t i = 0; i < Size; ++i)
    {
        mChildList[i]->mWorldPos = mChildList[i]->mRelativePos * mWorldScale +
            mWorldPos;

        mChildList[i]->SetWorldScale(mChildList[i]->mRelativeScale * mWorldScale);
    }
}

void CSceneComponent::SetRelativeScale(float x, float y, float z)
{
    SetRelativeScale(FVector3D(x, y, z));
}

void CSceneComponent::SetRelativeScale(const FVector2D& Scale)
{
    SetRelativeScale(FVector3D(Scale.x, Scale.y, mRelativeScale.z));
}

void CSceneComponent::SetRelativeScale(float x, float y)
{
    SetRelativeScale(FVector3D(x, y, mRelativeScale.z));
}

void CSceneComponent::SetRelativeRotation(const FVector3D& Rot)
{
    mRelativeRot = Rot;

    if (mParent)
    {
        mWorldRot = mRelativeRot + mParent->mWorldRot;
    }

    else
    {
        mWorldRot = mRelativeRot;
    }

    size_t  Size = mChildList.size();

    for (size_t i = 0; i < Size; ++i)
    {
        mChildList[i]->mWorldPos =
            mChildList[i]->mRelativePos.GetRatation(mWorldRot) + mWorldPos;

        mChildList[i]->SetWorldRotation(mChildList[i]->mRelativeRot + mWorldRot);
    }
}

void CSceneComponent::SetRelativeRotation(float x, float y, float z)
{
    SetRelativeRotation(FVector3D(x, y, z));
}

void CSceneComponent::SetRelativeRotation(const FVector2D& Rot)
{
    SetRelativeRotation(FVector3D(Rot.x, Rot.y, mRelativeRot.z));
}

void CSceneComponent::SetRelativeRotation(float x, float y)
{
    SetRelativeRotation(FVector3D(x, y, mRelativeRot.z));
}

void CSceneComponent::SetRelativeRotationX(float x)
{
    SetRelativeRotation(FVector3D(x, mRelativeRot.y, mRelativeRot.z));
}

void CSceneComponent::SetRelativeRotationY(float y)
{
    SetRelativeRotation(FVector3D(mRelativeRot.x, y, mRelativeRot.z));
}

void CSceneComponent::SetRelativeRotationZ(float z)
{
    SetRelativeRotation(FVector3D(mRelativeRot.x, mRelativeRot.y, z));
}

void CSceneComponent::SetRelativeRotationAxis(float Angle, const FVector3D& Axis)
{
}

void CSceneComponent::SetRelativePos(const FVector3D& Pos)
{
    mRelativePos = Pos;

    if (mParent)
    {
        mWorldPos = mRelativePos + mParent->mWorldPos;
    }

    else
    {
        mWorldPos = mRelativePos;
    }

    size_t  Size = mChildList.size();

    for (size_t i = 0; i < Size; ++i)
    {
        mChildList[i]->SetWorldPos(mChildList[i]->mRelativePos + mWorldPos);
    }
}

void CSceneComponent::SetRelativePos(float x, float y, float z)
{
    SetRelativePos(FVector3D(x, y, z));
}

void CSceneComponent::SetRelativePos(const FVector2D& Pos)
{
    SetRelativePos(FVector3D(Pos.x, Pos.y, mRelativePos.z));
}

void CSceneComponent::SetRelativePos(float x, float y)
{
    SetRelativePos(FVector3D(x, y, mRelativePos.z));
}

void CSceneComponent::SetWorldScale(const FVector3D& Scale)
{
    mWorldScale = Scale;

    if (mParent)
    {
        mRelativeScale = mWorldScale / mParent->mWorldScale;
    }

    else
    {
        mRelativeScale = mWorldScale;
    }

    size_t  Size = mChildList.size();

    for (size_t i = 0; i < Size; ++i)
    {
        mChildList[i]->SetWorldScale(mChildList[i]->mRelativeScale * mWorldScale);

        mChildList[i]->SetWorldPos(mChildList[i]->mRelativePos * mWorldScale * mWorldPos);
    }
}

void CSceneComponent::SetWorldScale(float x, float y, float z)
{
    SetWorldScale(FVector3D(x, y, z));
}

void CSceneComponent::SetWorldScale(const FVector2D& Scale)
{
    SetWorldScale(FVector3D(Scale.x, Scale.y, mWorldScale.z));
}

void CSceneComponent::SetWorldScale(float x, float y)
{
    SetWorldScale(FVector3D(x, y, mWorldScale.z));
}

void CSceneComponent::SetWorldRotation(const FVector3D& Rot)
{
    mWorldRot = Rot;

    if (mParent)
    {
        mRelativeRot = mWorldRot - mParent->mWorldRot;
    }

    else
    {
        mRelativeRot = mWorldRot;
    }

    size_t  Size = mChildList.size();

    for (size_t i = 0; i < Size; ++i)
    {
        mChildList[i]->SetWorldRotation(mChildList[i]->mRelativeRot + mWorldRot);

        mChildList[i]->SetWorldPos(
            mChildList[i]->mRelativePos.GetRatation(mWorldRot) + mWorldPos);
    }
}

void CSceneComponent::SetWorldRotation(float x, float y, float z)
{
    SetRelativeRotation(FVector3D(x, y, z));
}

void CSceneComponent::SetWorldRotation(const FVector2D& Rot)
{
    SetRelativeRotation(FVector3D(Rot.x, Rot.y, mRelativeRot.z));
}

void CSceneComponent::SetWorldRotation(float x, float y)
{
    SetRelativeRotation(FVector3D(x, y, mRelativeRot.z));
}

void CSceneComponent::SetWorldRotationX(float x)
{
    SetRelativeRotation(FVector3D(x, mRelativeRot.y, mRelativeRot.z));
}

void CSceneComponent::SetWorldRotationY(float y)
{
    SetRelativeRotation(FVector3D(mRelativeRot.x, y, mRelativeRot.z));
}

void CSceneComponent::SetWorldRotationZ(float z)
{
    SetRelativeRotation(FVector3D(mRelativeRot.x, mRelativeRot.y, z));
}

void CSceneComponent::SetWorldRotationAxis(float Angle, const FVector3D& Axis)
{
}

void CSceneComponent::SetWorldPos(const FVector3D& Pos)
{
    mWorldPos = Pos;

    if (mParent)
    {
        FVector3D RelativePos = mWorldPos - mParent->mWorldPos;
        mRelativePos = RelativePos.GetRatation(mParent->mWorldRot * -1.f);
    }

    else
    {
        mRelativePos = mWorldPos;
    }
    size_t  Size = mChildList.size();

    for (size_t i = 0; i < Size; ++i)
    {
        mChildList[i]->SetWorldPos(mChildList[i]->mRelativePos + mWorldPos);
    }
}

void CSceneComponent::SetWorldPos(float x, float y, float z)
{
    SetWorldPos(FVector3D(x, y, z));
}

void CSceneComponent::SetWorldPos(const FVector2D& Pos)
{
    SetRelativeRotation(FVector3D(Pos.x, Pos.y, mRelativePos.z));
}

void CSceneComponent::SetWorldPos(float x, float y)
{
    SetRelativeRotation(FVector3D(x, y, mRelativePos.z));
}
